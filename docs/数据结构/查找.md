#### 1、查找的基本概念

**查找也即检索**。

> 文件：**由记录组成的集合**，即含有大量数据的元素线性组合而成。
> 记录：**由若干数据项组成的数据元素**，这些数据项也常称作记录中的数据域，用以表示某个状态的物理意义。
> 关键字：**用以区分文件中记录的数据项的值**。若此关键字可以惟一地标识一个记录，则称此关键字为主关键字。也就是说，对于不同的记录，其对应的主关键字的值均不相同。若数据元素只有一个数据项，其关键字即为该数据元素的值。

**查找是指根据给定的某个值，确定关键字值，查询确定关键字值与给定值相等的记录在文件中的位置**。它是程序设计中一项重要的基本技术。查找的结果有两种情况：**若在文件中找到了待查找的记录，则称查找成功**，这时可以得到该记录在文件中的位置，或者得到该记录中其他的信息；**若在文件中没有找到所需要的记录，则称查找不成功或查找失败**，这时，相应的查找算法给出查找失败的信息，同时也得到记录插入文件的位置。

查找可分为**静态查找和动态查找**两种，**在查找过程中不修改查找表的长度和表中内容的方法称作静态查找，反之称作动态查找**。

#### 2、查找算法的评价指标

**平均查找长度（ASL）：**在查找的过程中，一次查找的长度是指需要比较的关键字次数，而平均查找长度则是所有查找过程中进行关键字的比较次数的平均值。

![](https://gitee.com/XiaoJing-C/images/raw/master/img/200751234_2_20200830082523661.jpg)

- n：记录的个数
- pi：查找第i个记录的概率 ( 通常认为pi =1/n )
- ci：找到第i个记录所需的比较次数

#### 3、静态查找表

##### 3.1 顺序查找

1）应用范围

顺序表或线性链表表示的静态查找表

2）顺序表的表示

```c
typedef struct { //查找表的数据结构
	ElemType *R; //元素存储空间基址
	int length; //表的长度
}SSTable;
```

3）性能分析

- 查找成功时的平均查找长度(设表中各记录查找概率相等)：ASL=(1+2+ … +n)/n =(n+1)/2
- 查找不成功时的平均查找长度：ASL =n+1

4）特点

- **算法简单**，对表结构无任何要求（顺序和链式）。
- n很大时，**平均查找长度较大**，查找**效率较低**。
- 改进措施：**非等概率查找时，可按照查找概率进行排序**。

##### 3.2 折半查找

1）算法思想：

设表长为n，low、high和mid分别指向待查元素所在区间的上界、下界和中点，k为给定值：

- 初始时，令low=1, high=n, mid=(low+high)/2；

- 让k与mid指向的记录比较：若k = R[mid].key，查找成功若k < R[mid].key，则high=mid-1若k > R[mid].key，则low=mid+1；

- 重复上述操作，直至low>high时，查找失败。

  

<div align=left><img src="https://gitee.com/XiaoJing-C/images/raw/master/img/200751234_5_20200830082523786.jpg" style="zoom:100%;" />

<div align=left><img src="https://gitee.com/XiaoJing-C/images/raw/master/img/200751234_4_20200830082523755.jpg" style="zoom:100%;" />

<div align=left><img src="https://gitee.com/XiaoJing-C/images/raw/master/img/200751234_5_20200830082523786 (1).jpg" style="zoom:100%;" />

2）折半查找的性能分析：

- 查找过程：每次将待查记录所在区间缩小一半，比顺序查找效率高，时间复杂度**O(log2 n)**
- 适用条件：采用**顺序存储结构**的有序表，不宜用于链式结构

##### 3.3 分块查找（块间有序，块内无序）

分块有序，即**分成若干子表，要求每个子表中的数值都比后一块中数值小**（但**子表内部未必有序**）。 然后将各子表中的最大关键字构成一个索引表，表中还要包含每个子表的起始地址（即头指针）。

<div align=left><img src="https://gitee.com/XiaoJing-C/images/raw/master/img/200751234_6_20200830082523849.jpg" style="zoom:100%;" />

1）分块查找过程：

- **对索引表使用折半查找法**（因为索引表是有序表）
- **确定了待查关键字所在的子表后，在子表内采用顺序查找法**（因为各子表内部是无序表）

2）分块查找优缺点：

- 优点：插入和删除比较容易，无需进行大量移动。
- 缺点：要增加一个索引表的存储空间并对初始索引表进行排序运算。
- 适用情况：若线性表既要**快速查找又经常动态变化**，则可采用分块查找

3）分块查找的性能分析

分块查找的平均长度为索引查找和块内查找的平均长度值和。设索引查找和块内查找的平均长度分别为 L1，L2，则分块查找的平均查找长度为

<div align=left><img src="https://gitee.com/XiaoJing-C/images/raw/master/img/QQ图片20210806165851.jpg" style="zoom:80%;" />

#### 4、B树和B+树

B树是一种**多路平衡查找树**，它的每一个结点最多包含 m 个孩子，m 被称为 B 树的阶。

B树主要应用于文件系统以及部分数据库索引，比如 MongoDB。

而大部分关系型数据库，比如 Mysql，则使用 B+ 树作为索引。

<div align=left><img src="https://gitee.com/XiaoJing-C/images/raw/master/img/20210806171844.png" style="zoom:80%;" />

**一个m阶的B树具有如下几个特征：**

- 树中每个结点**至多有 m 棵子树**，即**至多含有 m-1 个关键字**。
- 若根节点不是终端结点，则至少有两颗子树。
- 除根节点外的所有**非叶结点至少有⌈m/2⌉棵子树**，即**至少有⌈m/2⌉ - 1 个关键字**。
- **所有的叶子结点都位于同一层**，且不带信息。
- 每个节点中的元素**从小到大排列**。

**B树的高度**

若 n ≥ 1，则对任意一棵包含 n 个关键字、高度为 h 、阶数为 m 的 B 树。

**h ≥ logm(n+1)，h ≤ log⌈m/2⌉((n+1)/2)+1。**



**一个m阶的B+树具有如下特征：**

- 每个分支最多有 m 棵子树。
- 非叶根节点至少有两颗子树，其他每个**分支结点至少有 ⌈m/2⌉ 棵子树**。
- **结点子树个数与关键字个数相等**。
- 所有分支结点中仅包含它的各个子结点（即下一级的索引块）中关键字的最大值及指向其子结点的指针。
- 所有的**叶子结点中包含了全部元素的信息**，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。
- 在 B+ 树中，**叶结点包含了全部关键字**，即在非叶结点中出现的关键字也会出现在叶结点中；而在 B 树中，叶结点包含的关键字和其他结点包含的关键字是不重复的。

<div align=left><img src="https://gitee.com/XiaoJing-C/images/raw/master/img/20210806172519.png" style="zoom:80%;" />

**B+树的优势：**

- 单一节点存储更多的元素，使得查询的IO次数更少。
- 所有查询都要查找到叶子节点，查询性能稳定。
- 所有叶子节点形成有序链表，便于范围查询。

#### 5、哈希表的查找

1）基本思想：**记录的存储位置与关键字之间存在对应关系**：

优点：查找速度极快，为**O(1)**，查找效率与元素个数n无关。

**装填因子**

<div align=left><img src="https://gitee.com/XiaoJing-C/images/raw/master/img/20210806170231.png" style="zoom:100%;" />

